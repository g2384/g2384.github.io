<!--adapted from: http://babbage.cs.qc.cuny.edu/IEEE-754.old/Decimal.html -->
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<html><head>
  <title>
    Hex/Bin Calculator | IEEE-754 Conversion | Fix-point Bin Conversion
  </title>
  <style>body{font-family:Consolas;}input{font-family:Consolas;}.sign{color:#046A96;}.expo{color:#ee5500;}.mantissa{color:#33dd00;}.c { text-transform: uppercase; }
  </style>

</head>
<body>
<script language="JavaScript">
function conv(form) {
if(form.numin.value.match(/^[01 ]+$/)&&form.numin2.value.match(/^[01 ]+$/)){
form.numin.value = parseInt(form.numin.value.replace(/ /g, ""), 2).toString(16);
form.numin2.value = parseInt(form.numin2.value.replace(/ /g, ""), 2).toString(16);}
form.Conv.disabled=true;
x(form);
}
	
function x(form) {
if(form.numin.value.match(/^[01 ]+$/)&&form.numin2.value.match(/^[01 ]+$/)){
form.Conv.disabled=false;
}else{
form.Conv.disabled=true;
}
var in1=form.numin.value;
var in2=form.numin2.value;
if(form.numin.value==''){
in1=0;
}
if(form.numin2.value==''){
in2=0;
}

var number = parseInt(in1,16); //decimal out
var number2 = parseInt(in2,16); //decimal out

var Rsum = number + number2;
var Rsub = number - number2;
var Rmlt = number * number2;//multiplication
var Rquo = number / number2;//quotient

document.getElementById("r").innerHTML="Dec:<br>"+
number+" + "+number2+" = "+Rsum+"<br>"+
number+" - "+number2+" = "+Rsub+"<br>"+
number+" × "+number2+" = "+Rmlt+"<br>"+
number+" ÷ "+number2+" = "+Rquo+
"<br><br>Hex:<br>"+
in1+" + "+in2+" = "+Number(Rsum).toString(16)+"<br>"+
in1+" - "+in2+" = "+Number(Rsub).toString(16)+"<br>"+
in1+" × "+in2+" = "+Number(Rmlt).toString(16)+"<br>"+
in1+" ÷ "+in2+" = "+Number(Rquo).toString(16);
}
</script>
<form>
<h2>Hex/Bin Numbers Calculator</h2>
Enter A Hex/Bin: 
<input type="text" class="c" name="numin" size="20" onkeyup="x(this.form)"><br>
Enter B Hex/Bin: 
<input type="text" class="c" name="numin2" size="20" onkeyup="x(this.form)"><br>
<input type="Button" name="Conv" value="Convert to Hex" onclick="conv(this.form)" disabled=false>(only if input is Binary)<br>
<input type="Button" value="Calculate" onclick="x(this.form)"><br><br>
<div id="r" class="c"></div>
</form>
<script = "javascript">
function Convert2Bin(outstring, statstring, signBit, power, rounding)
{
  output = new String()                 //Output
  var binexpnt, index1, index2, cnst, bias, lastbit, rounded, index3, binexpnt2
  var moreBits
  cnst = 2102   // 1 (carry bit) + 1023 + 1 + 1022 + 53 + 2 (round bits)
  bias = 1024
  //init
  for (index1 = 0; index1 < this.Size; index1++)  this.Result[index1] = 0
  with (Math)
  {
    //Sign
    this.Result[0] = signBit
    //obtain exponent value
    index1 = 0
    if (this.Size == 32) index2 = 9
    else index2 = 12
    if (rounding && (statstring == "normal"))
    {
      //find most significant bit of mantissa
      while ((index1 < cnst) && (this.BinVal[index1] != 1)) index1++
      binexpnt = bias - index1
      //regular normalized numbers
      if (binexpnt >= this.MinExp)
      {
        //the value is shifted until the most
        index1++    //significant 1 is to the left of the binary
        //point and that bit is implicit in the encoding
      }//if normalized numbers
      //support for zero and denormalized numbers
      //exponent underflow for this precision
      else
      {
        binexpnt = this.MinExp - 1
        index1 = bias - binexpnt
      }//if zero or denormalized (else section)

      //use round to nearest value mode
      //compute least significant (low-order) bit of mantissa
      lastbit = this.Size - 1 - index2 + index1
      //the bits folllowing the low-order bit have a value of (at least) 1/2
      if (this.BinVal[lastbit + 1] == 1)
      {
        rounded = 0
        //odd low-order bit
        if (this.BinVal[lastbit] == 1)
        {
          //exactly 1/2 the way between odd and even rounds up to the even,
          //so the rest of the bits don't need to be checked to see if the value
          //is more than 1/2 since the round up to the even number will occur
          //anyway due to the 1/2
          rounded = 1
        }//if odd low-order bit
        //even low-order bit
        else  //this.BinVal[lastbit] == 0
        {
          //exactly 1/2 the way between even and odd rounds down to the even,
          //so the rest of the bits need to be checked to see if the value
          //is more than 1/2 in order to round up to the odd number
          index3 = lastbit + 2
          while ((rounded == 0) && (index3 < cnst))
          {
            rounded = this.BinVal[index3]
            index3++
          }//while checking for more than 1/2
        }//if even low-order bit (else section)
        //do rounding "additions"
        index3 = lastbit
        while ((rounded == 1) && (index3 >= 0))
        {
          // 0 + 1 -> 1 result with 0 carry
          if (this.BinVal[index3] == 0)
          {
            // 1 result
            this.BinVal[index3] = 1
            // 0 carry
            rounded = 0
          }//if bit is a 0
          // 1 + 1 -> 0 result with 1 carry
          else  //this.BinVal[index3] == 1
          {
            // 0 result
            this.BinVal[index3] = 0
            // 1 carry
//          rounded = 1
          }//if bit is a 1 (else section)
          index3--
        }//while "adding" carries from right to left in bits
      }//if at least 1/2
      //obtain exponent value
      index1 = index1 - 2
      if (index1 < 0) index1 = 0
    }//if rounding
    //find most significant bit of mantissa
    while ((index1 < cnst) && (this.BinVal[index1] != 1)) index1++
    binexpnt2 = bias - index1
    if (statstring == "normal")
    {
      binexpnt = binexpnt2
      //regular normalized numbers
      if ((binexpnt >= this.MinExp) && (binexpnt <= this.MaxExp))
      {
                                //the value is shifted until the most
        index1++                //significant 1 is to the left of the binary
                                //point and that bit is implicit in the encoding
      }//if normalized numbers
      //support for zero and denormalized numbers
      //exponent underflow for this precision
      else if (binexpnt < this.MinExp)
      {
        if (binexpnt2 == bias - cnst)
          //value is truely zero
          this.StatCond = "normal"
        else if (binexpnt2 < this.MinUnnormExp)
          this.StatCond = "underflow"
        else
          this.StatCond = "denormalized"
        binexpnt = this.MinExp - 1
        index1 = bias - binexpnt
      }//if zero or denormalized (else if section)
    }
    else //already special values
    {
      binexpnt = power
      index1 = bias - binexpnt
      if (binexpnt > this.MaxExp)
        binexpnt = this.MaxExp + 1
      else if (binexpnt < this.MinExp)
        binexpnt = this.MinExp - 1
    }//if already special (else section)
    //copy the result
    while ((index2 < this.Size) && (index1 < cnst))
    {
      this.Result[index2] = this.BinVal[index1]
      index2++
      index1++
    }//while
    //max exponent for this precision
    if ((binexpnt > this.MaxExp) || (statstring != "normal"))
    {
      //overflow of this precision, set infinity
      if (statstring == "normal")
      {
        binexpnt = this.MaxExp + 1
        this.StatCond = "overflow"
        this.DispStr = "Infinity"
        if (this.Result[0] == 1)
          this.DispStr = "-" + this.DispStr
        if (this.Size == 32) index2 = 9
        else index2 = 12
        //zero the mantissa
        while (index2 < this.Size)
        {
          this.Result[index2] = 0
          index2++
        }//while
      }//if overflowed
      else //already special values
      {
        this.StatCond = statstring
        this.DispStr = outstring
      }//if already special (else section)
    }//if max exponent
    //convert exponent value to binary representation
    if (this.Size == 32) index1 = 8
    else index1 = 11
    this.BinaryPower = binexpnt
    binexpnt += this.ExpBias    //bias
    while ((binexpnt / 2) != 0)
    {
      this.Result[index1] = binexpnt % 2
      if (binexpnt % 2 == 0) binexpnt = binexpnt / 2
        else binexpnt = binexpnt / 2 - 0.5
      index1 -= 1
    }
    //output binary result
    output = ""
    for (index1 = 0; index1 < this.Size; index1++)
      output = output + this.Result[index1]
    return output
  }//with Math
}
function Dec2Bin(input)
{
  var value, intpart, decpart, binexpnt, index1, cnst, bias
  cnst = 2102   // 1 (carry bit) + 1023 + 1 + 1022 + 53 + 2 (round bits)
  bias = 1024
  //init
  for (index1 = 0; index1 < cnst; index1++)  this.BinVal[index1] = 0
  with (Math)
  {
    input = Canonical(input)
    //Sign
    if (input.charAt(0) == "-")
      this.Result[0] = 1
    else
      this.Result[0] = 0
    //if value magnitude greater than 1.7976931348623157E+308, set infinity
    input = OvfCheck(input)
    if (input.indexOf("Infinity") != -1)
    {
      binexpnt = this.MaxExp + 1
      this.StatCond64 = "overflow"
      this.DispStr = input
    }//if greater than 1.7976931348623157E+308
    //Value magnitude is not greater than 1.7976931348623157E+308
    else
    {
      //if value magnitude less than 2.4703282292062328E-324, set "underflow".
      this.StatCond64 = UndfCheck(input)
      if (this.StatCond64 == "underflow")
      {
        binexpnt = this.MinExp - 1
      }//if less than 2.4703282292062328E-324
      //Value magnitude is not less than 2.4703282292062328E-324
      else
      {
        //convert 'input' from string to numeric
        input = input * 1.0
        //convert and seperate input to integer and decimal parts
        value = abs(input)
        intpart = floor(value)
        decpart = value - intpart
        //convert integer part
        index1 = bias
        while (((intpart / 2) != 0) && (index1 >= 0))
        {
          this.BinVal[index1] = intpart % 2
          if (intpart % 2 == 0) intpart = intpart / 2
            else intpart = intpart / 2 - 0.5
          index1 -= 1
        }
        //convert decimal part
        index1 = bias + 1
        while ((decpart > 0) && (index1 < cnst))
        {
          decpart *= 2
          if (decpart >= 1)
            {this.BinVal[index1] = 1; decpart --; index1++}
          else {this.BinVal[index1] = 0; index1++}
        }
        //obtain exponent value
        index1 = 0
        //find most significant bit of mantissa
        while ((index1 < cnst) && (this.BinVal[index1] != 1)) index1++
        binexpnt = bias - index1
        //support for zero and denormalized numbers
        //exponent underflow for this precision
        if (binexpnt < this.MinExp)
        {
          binexpnt = this.MinExp - 1
        }//if zero or denormalized
      }//if not less than 2.4703282292062328E-324 (else section)
    }//if not greater than 1.7976931348623157E+308 (else section)
    //output exponent value
    this.BinaryPower = binexpnt
  }//with Math
}
function Canonical(input)
{
  output = new String()
  numerals = new String()
  expstr = new String()
  signstr = new String()
  expsignstr = new String()
  expstrtmp = new String()
  var locE, stop, expnum, locDPact, locDP, start, MSDfound, index, expdelta
  var expstart, expprecision
  numerals = "0123456789";
  expprecision = 5
  input = input.toUpperCase()
  locE = input.indexOf("E");
  if (locE != -1)
  {
    stop = locE
    expstr = input.substring(locE + 1, input.length)
    expnum = expstr * 1
  }
  else
  {
    stop = input.length
    expnum = 0
  }
  locDPact = input.indexOf(".");
  if (locDPact != -1)
    locDP = locDPact
  else
    locDP = stop
  start = 0
  if (input.charAt(start) == "-")
  {
    start++
    signstr = "-"
  }
  else if (input.charAt(start) == "+")
  {
    start++
    signstr = "+"
  }
  else
    signstr = "+"
  MSDfound = false
  while ((start < stop) && !MSDfound)
  {
    index = 1
    while (index < numerals.length)
    {
      if (input.charAt(start) == numerals.charAt(index))
      {
        MSDfound = true
        break
      }
      index++
    }
    start++
  }
  start--
  if (MSDfound)
  {
    expdelta = locDP - start
    if (expdelta > 0)
      expdelta = expdelta - 1
    expnum = expnum + expdelta
  }
  else  //No significant digits found, value is zero
    expnum = 0
  expstrtmp = "" + expnum
  expstart = 0
  if (expstrtmp.charAt(expstart) == "-")
  {
    expstart++
    expsignstr = "-"
  }
  else
    expsignstr = "+"
  expstr = "E" + expsignstr
  index = 0
  while (index < expprecision - expstrtmp.length + expstart)
  {
    expstr += "0"
    index++
  }
  expstr += expstrtmp.substring(expstart, expstrtmp.length)
  output = signstr
  if (locDPact == start + 1)
  {
    output += input.substring(start, stop)
  }
  else if (stop == start + 1)
  {
    output += input.substring(start, stop)
    output += "."
  }
  else if (locDPact < start)
  {
    output += input.substring(start, start + 1)
    output += "."
    output += input.substring(start + 1, stop)
  }
  else if (locDPact != -1)
  {
    output += input.substring(start, start + 1)
    output += "."
    output += input.substring(start + 1, locDPact)
    output += input.substring(locDPact + 1, stop)
  }
  else
  {
    output += input.substring(start, stop)
    output += "."
  }
  output += expstr
  return output;
}
function MostSigOrder(input)
{
  output = new String()
  expstr = new String()
  var expprecision, expbias, stop, expnum, index
  expprecision = 5
  expbias = 50000
  stop = input.indexOf("E");
  output = input.substring(stop + 1, input.length)
  expnum = output * 1
  expnum += expbias
  expstr = "" + expnum
  output = expstr
  index = 0
  while (index < expprecision - expstr.length)
  {
    output = "0" + output
    index++
  }
  output += input.substring(1, 2)
  output += input.substring(3, stop)
  return output;
}
function A_gt_B(A, B)
{
  numerals = new String()
  var greater, stop, index, Adigit, Bdigit
  numerals = "0123456789";
  greater = false
  if (A.length > B.length)
    stop = A.length
  else
    stop = B.length
  index = 0
  while (index < stop)
  {
    if (index < A.length)
      Adigit = numerals.indexOf(A.charAt(index))
    else
      Adigit = 0
    if (index < B.length)
      Bdigit = numerals.indexOf(B.charAt(index))
    else
      Bdigit = 0
    if (Adigit < Bdigit)
      break
    else if (Adigit > Bdigit)
    {
      greater = true
      break
    }
    index++
  }//end while
  return greater;
}
function OvfCheck(input)
{
  output = new String()
  //Is value magnitude greater than +1.7976931348623157E+00308
  if (A_gt_B(MostSigOrder(input), "5030817976931348623157"))
  {
    output = "Infinity"
    if (input.charAt(0) == "-")
      output = "-" + output
  }
  else
    output = input
  return output;
}
function UndfCheck(input)
{
  output = new String()
  //Is value magnitude less than +2.4703282292062328E-00324
  if (A_gt_B("4967624703282292062328", MostSigOrder(input)))
    output = "underflow"
  else
    output = "normal"
  return output;
}
function Convert2Hex()
{
  output = new String()
  numerals = new String()
  var temp, index, i
  numerals = "0123456789ABCDEF"
  with (Math)
  {
    //convert binary result to hex and output
    for (index = 0; index < this.Size; index +=4)
    {
      temp = 0
      for (i = 0; i < 4; i++)
        temp += pow(2, 3 - i)*this.Result[index + i]
      output = output + numerals.charAt(temp)
    }
  }
  return output
}
function numStrClipOff(input, precision)
{
  result = new String()
  numerals = new String()
  tempstr = new String()
  expstr = new String()
  signstr = ""
  var locE, stop, expnum, locDP, start, MSD, MSDfound, index, expdelta, digits
  var number
  numerals = "0123456789";
  tempstr = input.toUpperCase()
  locE = tempstr.indexOf("E");
  if (locE != -1)
  {
    stop = locE
    expstr = input.substring(locE + 1, input.length)
    expnum = expstr * 1
  }
  else
  {
    stop = input.length
    expnum = 0
  }
  if (input.indexOf(".") == -1)
  {
    tempstr = input.substring(0, stop)
    tempstr += "."
    if (input.length != stop)
      tempstr += input.substring(locE, input.length)
    input = tempstr
    locE = locE + 1
    stop = stop + 1
  }
  locDP = input.indexOf(".");
  start = 0
  if (input.charAt(start) == "-")
  {
    start++
    signstr = "-"
  }
  MSD = start
  MSDfound = false
  while ((MSD < stop) && !MSDfound)
  {
    index = 1
    while (index < numerals.length)
    {
      if (input.charAt(MSD) == numerals.charAt(index))
      {
        MSDfound = true
        break
      }
      index++
    }
    MSD++
  }
  MSD--
  if (MSDfound)
  {
    expdelta = locDP - MSD
    if (expdelta > 0)
      expdelta = expdelta - 1
    expnum = expnum + expdelta
    expstr = "e" + expnum
  }
  else  //No significant digits found, value is zero
    MSD = start
  digits = stop - MSD
  tempstr = input.substring(MSD, stop)
  if (tempstr.indexOf(".") != -1)
    digits = digits - 1
  number = digits
  if (precision < digits)
    number = precision
  tempstr = input.substring(MSD, MSD + number + 1)
  if ( (MSD != start) || (tempstr.indexOf(".") == -1) )
  {
    result = (signstr +input.substring(MSD, MSD + 1)+"." + input.substring(MSD + 1, MSD + number))
    while (digits < precision)
    {
      result += "0"
      digits += 1
    }
    result += expstr
  }
  else
  {
    result = input.substring(0, start + number + 1)
    while (digits < precision)
    {
      result += "0"
      digits += 1
    }
    if (input.length != stop)
      result += input.substring(locE, input.length)
  }
  return result;
}

//object construction function
function ieee (Size){
  this.Size = Size
  this.BinaryPower = 0
  this.DecValue = ""
  this.DispStr = ""
  this.Convert2Bin = Convert2Bin   //convert input to bin.
  this.Convert2Hex = Convert2Hex   //convert bin. to hex.
  this.Convert2Dec = Convert2Dec   //convert bin. significand to dec.
  this.Dec2Bin = Dec2Bin           //convert dec. to bin.
  this.StatCond = "normal"
  this.StatCond64 = "normal"
  this.BinString = ""
  // 1 (carry bit) + 1023 + 1 + 1022 + 53 + 2 (round bits)
  this.BinVal = new Array(2102)    //Binary Representation
  if (Size == 32){
    this.ExpBias = 127
    this.MaxExp = 127
    this.MinExp = -126
    this.MinUnnormExp = -149
    this.Result = new Array(32)
  }
  else if (Size == 64){
    this.ExpBias = 1023
    this.MaxExp = 1023
    this.MinExp = -1022
    this.MinUnnormExp = -1074
    this.Result = new Array(64)
  }
}
function compute(obj, rounding){
/*
  in this javascript program, bit positions are numbered
  0 ~ 32/64 from left to right instead of right to left, the
  way the output is presented
*/
  ieee32 = new ieee(32)
  ieee64 = new ieee(64)
  var input, index1, cnst
  input = obj.input.value
  input = input.replace(/^([0-9\-])([0-9\.eE\-]*)[^0-9\.eE\-]/g,"$1$2");
  //input = input.replace(/^[^0-9\-]/g,"");
  obj.input.value = input;
  ieee64.Dec2Bin(input)
  ieee64.BinString =
    ieee64.Convert2Bin(ieee64.DispStr, ieee64.StatCond64, ieee64.Result[0],
                         ieee64.BinaryPower, false)
						 var output_str="";
	var prefix='<font class="sign">Sign</font> <font class="expo">Exponent</font> <font class="mantissa">Mantissa</font><br>';
  output_str = 'Double precision (64 bits):<br>'+prefix+'<font class="sign">'+ieee64.BinString.substring(0, 1)+'</font>';
  output_str += ('<font class="expo">'+ieee64.BinString.substring(1, 12)+'</font>');
  if ((ieee64.BinaryPower < ieee64.MinExp) ||
      (ieee64.BinaryPower > ieee64.MaxExp))
  {
    output_str += ('<font class="mantissa">'+ieee64.BinString.substring(12, 13)+'</font>');
    output_str += ("." + ieee64.BinString.substring(13, 64)+'</font>');
  }
  else
  {
    output_str += ('<font class="mantissa">'+ieee64.BinString.substring(12, 64)+'</font>');
  }
  if (ieee64.StatCond != "normal")
  output_str +=("<br>Status:" + ieee64.StatCond);
  
  output_str +=("<br>Hex: "+ ieee64.Convert2Hex());
  
  if (ieee64.DispStr != "")
  {
    output_str +=("<br>Dec: "+ ieee64.DispStr);
  }
  else{
  ieee64.Convert2Dec()
  output_str +=("<br>Dec: "+ ieee64.DecValue);
	}
  document.getElementById("bin64_0").innerHTML=output_str;
    cnst = 2102         // 1 (carry bit) + 1023 + 1 + 1022 + 53 + 2 (round bits)
    for (index1 = 0; index1 < cnst; index1++)
      ieee32.BinVal[index1] = ieee64.BinVal[index1]
  ieee32.BinString = ieee32.Convert2Bin(ieee64.DispStr, ieee64.StatCond64, ieee64.Result[0], ieee64.BinaryPower, rounding)
						 

  output_str = 'Single precision (32 bits):<br>'+prefix+'<font class="sign">'+ieee32.BinString.substring(0, 1)+'</font>';
  output_str += ('<font class="expo">'+ieee32.BinString.substring(1, 9)+'</font>');
  if ((ieee32.BinaryPower < ieee32.MinExp) ||
      (ieee32.BinaryPower > ieee32.MaxExp))
  {
    output_str += ('<font class="mantissa">'+ieee32.BinString.substring(9, 10))
    output_str += ("." + ieee32.BinString.substring(10, 32)+'</font>');
  }
  else
  {
    output_str += ('<font class="mantissa">'+ieee32.BinString.substring(9, 32)+'</font>');
  }
  if (ieee32.StatCond != "normal")
  output_str +=("<br>Status:" + ieee32.StatCond);
  
  
  output_str +=("<br>Hex: "+ ieee32.Convert2Hex());
if (ieee32.DispStr != "")
  {
    output_str +=("<br>Dec: "+ ieee32.DispStr);
  }
  else{
  ieee32.Convert2Dec()
    output_str +=("<br>Dec: "+ ieee32.DecValue);
	}
	document.getElementById("bin32_0").innerHTML=output_str;
}
function Convert2Dec()
{
  var s, i, dp, val, hid, temp, decValue, power
  with (Math)
  {
  if (this.Size == 32) s = 9
  else s = 12
  if ((this.BinaryPower < this.MinExp) || (this.BinaryPower > this.MaxExp))
  {
    dp = 0
    val = 0
  }
  else
  {
    dp = - 1
    val = 1
  }
  for (i = s; i < this.Size; i++)
    val += parseInt(this.Result[i])*pow(2, dp + s - i)
  decValue = val * pow(2, this.BinaryPower)
  if (this.Size == 32)
  {
    s = 8
    if (val > 0)
    {
      power = floor( log(decValue) / LN10 )
      decValue += 0.5 * pow(10, power - s + 1)
      val += 5E-8
    }
  }
  else s = 17
  if (this.Result[0] == 1) decValue = - decValue
  //the system refuses to display negative "0"s with a minus sign
  this.DecValue = "" + decValue
  if ((this.DecValue == "0") && (this.Result[0] == 1))
    this.DecValue = "-" + this.DecValue
  this.DecValue = numStrClipOff(this.DecValue, s)

  }
}
function HextoFP(){
var a=document.getElementById("hexinput").value;
if(a.indexOf("0x")<0){a="0x"+a;}
if(a.length<10){a=(a+"00000000").slice(0,10);
}
document.getElementById("result").innerHTML= (a & 0x7fffff | 0x800000) * 1.0 / Math.pow(2,23) * Math.pow(2,  ((a>>23 & 0xff) - 127));
document.getElementById("hexinput").value=a;}
function HextoDP(){
var a=document.getElementById("hexinput").value;
if(a.indexOf("0x")<0)a="0x"+a;
if(a.length<18)a=(a+"0000000000000000").slice(0,16);
document.getElementById("result").innerHTML=  (a & 0xfffff | 0x100000) * 1.0 / Math.pow(2, 52 - 32) * Math.pow(2, ((a >> 52 - 32 & 0x7ff) - 1023));
document.getElementById("hexinput").value=a;}
</script>
<br><hr><br>

<h2>Dec -> IEEE-754 Float/Double</h2>
IEEE-754 Floating-Point Conversion<br>
<form>
Input: <input type="text" placeholder="Decimal Floating-Point" onkeyup="compute(this.form, true)" name="input">
<input type="button" value="Rounded(default)" onClick="compute(this.form, true)">
<input type="button" value="Not Rounded" onClick="compute(this.form, false)">
<br>
Round: uses the IEEE-754 round-to-nearest-value mode.<br><br>

<div id="bin32_0"></div>
<br>
<div id="bin64_0"></div>
</form><br><hr>
<h2>Hex(IEEE-754 Float/Double) -> Dec</h2><br>
Input: <input type="text" id="hexinput" placeholder="Input Hex">
<input type="button" onclick="HextoFP()" value="Hex To Float">
<input type="button" onclick="HextoDP()" value="Hex To Double"><br>
<div id="result"></div>
<br><hr><br>
<h2>Fix-Point <-> Dec Converter</h2><br>
Bin:<input type="text" class="c" id="bin" size="32"><input type="button" onclick="init(1)" value="Calc">
<br>
Dec:<input type="text" class="c" id="din" size="32"><input type="button" onclick="init(0)" value="Calc">
<div id="fp_r"></div>
<script>
function init(s) {
    var o, a,str="";
    var v;
    if (s) {
        o = document.getElementById("bin");
        a = o.value;
        a = a.replace(/[^01\.]/g, "");
    } else {
        o = document.getElementById("din");
        a = o.value;
        a = a.replace(/[^0-9\.]/g, "");
    }
    v = a.indexOf(".");
    if (v == 0) {
        a = "0" + a;
    } else if (v < 0) {
        a = a + ".0";
    }
    o.value = a;
	str="-------<br />result:<br />";
	if(s){
	str+=fp_to_dec(a);
	}else{
	var k=dec_to_fp(a);
	str+="to Fixed-Point Bin:<br />"+k+"<br />back to Dec:<br />"+fp_to_dec(k);
	}
    document.getElementById("fp_r").innerHTML=str;
}

function fp_to_dec(a) {
    var result = 0;
    var b = a.split(".");
    var c = b[0].split("");

    var l = c.length - 1;
    for (var i = 0; i <= l; i++) {
        result += (1 << (l - i)) * c[i];
        console.log("b:" + result, c[i])
    }
    c = b[1].split("");

    l = (c.length - 1)>30?30:(c.length - 1);
    for (var i = 0; i <= l; i++) {
        result += (1 / (1 << (i + 1))) * c[i];
        console.log("a:" + result, c[i], (1 / (1 << (i + 1))))
    }
	return result;
}

function dec_to_fp(a) {
    var result = "";
    var b = a.split(".");

    var c = Number(b[0]);

    var k = 0,
        f = 1, p=1 / (1 << 30),q=1;
    var p1 = 30,
        p2 = 60;
    result = Number(c).toString(2) + ".";
    c = Number("0." + b[1]);
    if (c > 0) {
        for (var i = 1; i < p2; i++) {
		f=f/2;
		if(f<p){
		q=0;
			f*=10000000000;
			c*=10000000000;
			}
            k = (c - f) > 0;
            result += k ? "1" : "0";
            c = k ? c - f : c;
            console.log(result, c, k, c - f,p)
			
        }
    } else {
        result += "0";
    }
	return result;
	
}
</script>

</body>
</html>
