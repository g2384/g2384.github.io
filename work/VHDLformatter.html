<html>
<head>
<title>VHDL Beautifier, Formatter Online</title>
<style>
body{margin:0 auto;max-width:960px;tab-size: 4;  font-family:Helvetica, arial;}
textarea{width:100%;font-family:Consolas,Courier;}
.btn{
margin: 10px 10px;
padding: 5px 8px;
font-size: 16px;
line-height: 1.33;
border-radius: 3px;
color: #333;
border-color: #ccc;
cursor: pointer;
text-align: center;
white-space: nowrap;
border: 1px solid rgb(194, 194, 194);}
.btn:hover{background-color:#afd9ee;}
.show{display:none;}
input[type="checkbox"] + label {
    display:inline-block;
    width:19px;
    height:19px;
    margin:-1px 4px 0 0;
}
.wordwrap{
    white-space: pre-wrap;
    white-space: -moz-pre-wrap;
    white-space: -pre-wrap;
    white-space: -o-pre-wrap;
    word-wrap: break-word;
}
label{cursor:pointer;line-height:1.5em;}
label:hover{color:#555;text-decoration:underline;}
form{margin-bottom: 0px;}
a{color:#4b9aff;text-decoration:none;}
a:hover{text-decoration:underline;}
.hljs{display:block;overflow-x:auto;padding:.5em;-webkit-text-size-adjust:none}.hljs,.hljs-subst,.hljs-tag .hljs-title,.nginx .hljs-title{color:#000}.hljs-string,.hljs-title,.hljs-constant,.hljs-parent,.hljs-tag .hljs-value,.hljs-rules .hljs-value,.hljs-preprocessor,.hljs-pragma,.haml .hljs-symbol,.ruby .hljs-symbol,.ruby .hljs-symbol .hljs-string,.hljs-template_tag,.django .hljs-variable,.smalltalk .hljs-class,.hljs-addition,.hljs-flow,.hljs-stream,.bash .hljs-variable,.apache .hljs-tag,.apache .hljs-cbracket,.tex .hljs-command,.tex .hljs-special,.erlang_repl .hljs-function_or_atom,.asciidoc .hljs-header,.markdown .hljs-header,.coffeescript .hljs-attribute{color:#800}.smartquote,.hljs-comment,.hljs-annotation,.diff .hljs-header,.hljs-chunk,.asciidoc .hljs-blockquote,.markdown .hljs-blockquote{color:#888}.hljs-number,.hljs-date,.hljs-regexp,.hljs-literal,.hljs-hexcolor,.smalltalk .hljs-symbol,.smalltalk .hljs-char,.go .hljs-constant,.hljs-change,.lasso .hljs-variable,.makefile .hljs-variable,.asciidoc .hljs-bullet,.markdown .hljs-bullet,.asciidoc .hljs-link_url,.markdown .hljs-link_url{color:#080}.hljs-label,.hljs-javadoc,.ruby .hljs-string,.hljs-decorator,.hljs-filter .hljs-argument,.hljs-localvars,.hljs-array,.hljs-attr_selector,.hljs-important,.hljs-pseudo,.hljs-pi,.haml .hljs-bullet,.hljs-doctype,.hljs-deletion,.hljs-envvar,.hljs-shebang,.apache .hljs-sqbracket,.nginx .hljs-built_in,.tex .hljs-formula,.erlang_repl .hljs-reserved,.hljs-prompt,.asciidoc .hljs-link_label,.markdown .hljs-link_label,.vhdl .hljs-attribute,.clojure .hljs-attribute,.asciidoc .hljs-attribute,.lasso .hljs-attribute,.coffeescript .hljs-property,.hljs-phony{color:#88f}.hljs-keyword,.hljs-id,.hljs-title,.hljs-built_in,.css .hljs-tag,.hljs-javadoctag,.hljs-phpdoc,.hljs-dartdoc,.hljs-yardoctag,.smalltalk .hljs-class,.hljs-winutils,.bash .hljs-variable,.apache .hljs-tag,.hljs-type,.hljs-typename,.tex .hljs-command,.asciidoc .hljs-strong,.markdown .hljs-strong,.hljs-request,.hljs-status{font-weight:700}.asciidoc .hljs-emphasis,.markdown .hljs-emphasis{font-style:italic}.nginx .hljs-built_in{font-weight:400}.coffeescript .javascript,.javascript .xml,.lasso .markup,.tex .hljs-formula,.xml .javascript,.xml .vbscript,.xml .css,.xml .hljs-cdata{opacity:.5}
</style>
<script>
!function(e){"undefined"!=typeof exports?e(exports):(window.hljs=e({}),"function"==typeof define&&define.amd&&define([],function(){return window.hljs}))}(function(e){function n(e){return e.replace(/&/gm,"&amp;").replace(/</gm,"&lt;").replace(/>/gm,"&gt;")}function t(e){return e.nodeName.toLowerCase()}function r(e,n){var t=e&&e.exec(n);return t&&0==t.index}function a(e){var n=(e.className+" "+(e.parentNode?e.parentNode.className:"")).split(/\s+/);return n=n.map(function(e){return e.replace(/^lang(uage)?-/,"")}),n.filter(function(e){return N(e)||/no(-?)highlight/.test(e)})[0]}function o(e,n){var t={};for(var r in e)t[r]=e[r];if(n)for(var r in n)t[r]=n[r];return t}function i(e){var n=[];return function r(e,a){for(var o=e.firstChild;o;o=o.nextSibling)3==o.nodeType?a+=o.nodeValue.length:1==o.nodeType&&(n.push({event:"start",offset:a,node:o}),a=r(o,a),t(o).match(/br|hr|img|input/)||n.push({event:"stop",offset:a,node:o}));return a}(e,0),n}function c(e,r,a){function o(){return e.length&&r.length?e[0].offset!=r[0].offset?e[0].offset<r[0].offset?e:r:"start"==r[0].event?e:r:e.length?e:r}function i(e){function r(e){return" "+e.nodeName+'="'+n(e.value)+'"'}l+="<"+t(e)+Array.prototype.map.call(e.attributes,r).join("")+">"}function c(e){l+="</"+t(e)+">"}function u(e){("start"==e.event?i:c)(e.node)}for(var s=0,l="",f=[];e.length||r.length;){var g=o();if(l+=n(a.substr(s,g[0].offset-s)),s=g[0].offset,g==e){f.reverse().forEach(c);do u(g.splice(0,1)[0]),g=o();while(g==e&&g.length&&g[0].offset==s);f.reverse().forEach(i)}else"start"==g[0].event?f.push(g[0].node):f.pop(),u(g.splice(0,1)[0])}return l+n(a.substr(s))}function u(e){function n(e){return e&&e.source||e}function t(t,r){return RegExp(n(t),"m"+(e.cI?"i":"")+(r?"g":""))}function r(a,i){if(!a.compiled){if(a.compiled=!0,a.k=a.k||a.bK,a.k){var c={},u=function(n,t){e.cI&&(t=t.toLowerCase()),t.split(" ").forEach(function(e){var t=e.split("|");c[t[0]]=[n,t[1]?Number(t[1]):1]})};"string"==typeof a.k?u("keyword",a.k):Object.keys(a.k).forEach(function(e){u(e,a.k[e])}),a.k=c}a.lR=t(a.l||/\b[A-Za-z0-9_]+\b/,!0),i&&(a.bK&&(a.b="\\b("+a.bK.split(" ").join("|")+")\\b"),a.b||(a.b=/\B|\b/),a.bR=t(a.b),a.e||a.eW||(a.e=/\B|\b/),a.e&&(a.eR=t(a.e)),a.tE=n(a.e)||"",a.eW&&i.tE&&(a.tE+=(a.e?"|":"")+i.tE)),a.i&&(a.iR=t(a.i)),void 0===a.r&&(a.r=1),a.c||(a.c=[]);var s=[];a.c.forEach(function(e){e.v?e.v.forEach(function(n){s.push(o(e,n))}):s.push("self"==e?a:e)}),a.c=s,a.c.forEach(function(e){r(e,a)}),a.starts&&r(a.starts,i);var l=a.c.map(function(e){return e.bK?"\\.?("+e.b+")\\.?":e.b}).concat([a.tE,a.i]).map(n).filter(Boolean);a.t=l.length?t(l.join("|"),!0):{exec:function(){return null}}}}r(e)}function s(e,t,a,o){function i(e,n){for(var t=0;t<n.c.length;t++)if(r(n.c[t].bR,e))return n.c[t]}function c(e,n){return r(e.eR,n)?e:e.eW?c(e.parent,n):void 0}function f(e,n){return!a&&r(n.iR,e)}function g(e,n){var t=x.cI?n[0].toLowerCase():n[0];return e.k.hasOwnProperty(t)&&e.k[t]}function p(e,n,t,r){var a=r?"":E.classPrefix,o='<span class="'+a,i=t?"":"</span>";return o+=e+'">',o+n+i}function d(){if(!w.k)return n(y);var e="",t=0;w.lR.lastIndex=0;for(var r=w.lR.exec(y);r;){e+=n(y.substr(t,r.index-t));var a=g(w,r);a?(B+=a[1],e+=p(a[0],n(r[0]))):e+=n(r[0]),t=w.lR.lastIndex,r=w.lR.exec(y)}return e+n(y.substr(t))}function h(){if(w.sL&&!R[w.sL])return n(y);var e=w.sL?s(w.sL,y,!0,L[w.sL]):l(y);return w.r>0&&(B+=e.r),"continuous"==w.subLanguageMode&&(L[w.sL]=e.top),p(e.language,e.value,!1,!0)}function v(){return void 0!==w.sL?h():d()}function b(e,t){var r=e.cN?p(e.cN,"",!0):"";e.rB?(M+=r,y=""):e.eB?(M+=n(t)+r,y=""):(M+=r,y=t),w=Object.create(e,{parent:{value:w}})}function m(e,t){if(y+=e,void 0===t)return M+=v(),0;var r=i(t,w);if(r)return M+=v(),b(r,t),r.rB?0:t.length;var a=c(w,t);if(a){var o=w;o.rE||o.eE||(y+=t),M+=v();do w.cN&&(M+="</span>"),B+=w.r,w=w.parent;while(w!=a.parent);return o.eE&&(M+=n(t)),y="",a.starts&&b(a.starts,""),o.rE?0:t.length}if(f(t,w))throw new Error('Illegal lexeme "'+t+'" for mode "'+(w.cN||"<unnamed>")+'"');return y+=t,t.length||1}var x=N(e);if(!x)throw new Error('Unknown language: "'+e+'"');u(x);for(var w=o||x,L={},M="",k=w;k!=x;k=k.parent)k.cN&&(M=p(k.cN,"",!0)+M);var y="",B=0;try{for(var C,j,I=0;;){if(w.t.lastIndex=I,C=w.t.exec(t),!C)break;j=m(t.substr(I,C.index-I),C[0]),I=C.index+j}m(t.substr(I));for(var k=w;k.parent;k=k.parent)k.cN&&(M+="</span>");return{r:B,value:M,language:e,top:w}}catch(A){if(-1!=A.message.indexOf("Illegal"))return{r:0,value:n(t)};throw A}}function l(e,t){t=t||E.languages||Object.keys(R);var r={r:0,value:n(e)},a=r;return t.forEach(function(n){if(N(n)){var t=s(n,e,!1);t.language=n,t.r>a.r&&(a=t),t.r>r.r&&(a=r,r=t)}}),a.language&&(r.second_best=a),r}function f(e){return E.tabReplace&&(e=e.replace(/^((<[^>]+>|\t)+)/gm,function(e,n){return n.replace(/\t/g,E.tabReplace)})),E.useBR&&(e=e.replace(/\n/g,"<br>")),e}function g(e,n,t){var r=n?x[n]:t,a=[e.trim()];return e.match(/(\s|^)hljs(\s|$)/)||a.push("hljs"),r&&a.push(r),a.join(" ").trim()}function p(e){var n=a(e);if(!/no(-?)highlight/.test(n)){var t;E.useBR?(t=document.createElementNS("http://www.w3.org/1999/xhtml","div"),t.innerHTML=e.innerHTML.replace(/\n/g,"").replace(/<br[ \/]*>/g,"\n")):t=e;var r=t.textContent,o=n?s(n,r,!0):l(r),u=i(t);if(u.length){var p=document.createElementNS("http://www.w3.org/1999/xhtml","div");p.innerHTML=o.value,o.value=c(u,i(p),r)}o.value=f(o.value),e.innerHTML=o.value,e.className=g(e.className,n,o.language),e.result={language:o.language,re:o.r},o.second_best&&(e.second_best={language:o.second_best.language,re:o.second_best.r})}}function d(e){E=o(E,e)}function h(){if(!h.called){h.called=!0;var e=document.querySelectorAll("pre code");Array.prototype.forEach.call(e,p)}}function v(){addEventListener("DOMContentLoaded",h,!1),addEventListener("load",h,!1)}function b(n,t){var r=R[n]=t(e);r.aliases&&r.aliases.forEach(function(e){x[e]=n})}function m(){return Object.keys(R)}function N(e){return R[e]||R[x[e]]}var E={classPrefix:"hljs-",tabReplace:null,useBR:!1,languages:void 0},R={},x={};return e.highlight=s,e.highlightAuto=l,e.fixMarkup=f,e.highlightBlock=p,e.configure=d,e.initHighlighting=h,e.initHighlightingOnLoad=v,e.registerLanguage=b,e.listLanguages=m,e.getLanguage=N,e.inherit=o,e.IR="[a-zA-Z][a-zA-Z0-9_]*",e.UIR="[a-zA-Z_][a-zA-Z0-9_]*",e.NR="\\b\\d+(\\.\\d+)?",e.CNR="(\\b0[xX][a-fA-F0-9]+|(\\b\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)",e.BNR="\\b(0b[01]+)",e.RSR="!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|-|-=|/=|/|:|;|<<|<<=|<=|<|===|==|=|>>>=|>>=|>=|>>>|>>|>|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~",e.BE={b:"\\\\[\\s\\S]",r:0},e.ASM={cN:"string",b:"'",e:"'",i:"\\n",c:[e.BE]},e.QSM={cN:"string",b:'"',e:'"',i:"\\n",c:[e.BE]},e.PWM={b:/\b(a|an|the|are|I|I'm|isn't|don't|doesn't|won't|but|just|should|pretty|simply|enough|gonna|going|wtf|so|such)\b/},e.CLCM={cN:"comment",b:"//",e:"$",c:[e.PWM]},e.CBCM={cN:"comment",b:"/\\*",e:"\\*/",c:[e.PWM]},e.HCM={cN:"comment",b:"#",e:"$",c:[e.PWM]},e.NM={cN:"number",b:e.NR,r:0},e.CNM={cN:"number",b:e.CNR,r:0},e.BNM={cN:"number",b:e.BNR,r:0},e.CSSNM={cN:"number",b:e.NR+"(%|em|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|in|pt|pc|px|deg|grad|rad|turn|s|ms|Hz|kHz|dpi|dpcm|dppx)?",r:0},e.RM={cN:"regexp",b:/\//,e:/\/[gimuy]*/,i:/\n/,c:[e.BE,{b:/\[/,e:/\]/,r:0,c:[e.BE]}]},e.TM={cN:"title",b:e.IR,r:0},e.UTM={cN:"title",b:e.UIR,r:0},e});hljs.registerLanguage("vhdl",function(e){return{cI:!0,k:{keyword:"abs access after alias all and architecture array assert attribute begin block body buffer bus case component configuration constant context cover disconnect downto default else elsif end entity exit fairness file for force function generate generic group guarded if impure in inertial inout is label library linkage literal loop map mod nand new next nor not null of on open or others out package port postponed procedure process property protected pure range record register reject release rem report restrict restrict_guarantee return rol ror select sequence severity shared signal sla sll sra srl strong subtype then to transport type unaffected units until use variable vmode vprop vunit wait when while with xnor xor resize image pathname",typename:"boolean bit character severity_level integer time delay_length natural positive string bit_vector file_open_kind file_open_status std_ulogic std_ulogic_vector std_logic std_logic_vector unsigned signed boolean_vector integer_vector real_vector time_vector"},i:"{",c:[e.CBCM,{cN:"comment",b:"--",e:"$"},e.QSM,e.CNM,{cN:"literal",b:"'(U|X|0|1|Z|W|L|H|-)'",c:[e.BE]},{cN:"attribute",b:"'[A-Za-z](_?[A-Za-z0-9])*",c:[e.BE]}]}});

function selectText(element) {
	var doc = document, text = element, range, selection;
	if (doc.body.createTextRange) { //ms
		range = doc.body.createTextRange();
		range.moveToElementText(text);
		range.select();
	} else if (window.getSelection) { //all others
		selection = window.getSelection();
		range = doc.createRange();
		range.selectNodeContents(text);
		selection.removeAllRanges();
		selection.addRange(range);
	}
}
</script>
</head>
<body>
<h2 style="height:100px;color: #ccc;margin-top: 100px;">Please use the <a href="https://g2384.github.io/VHDLFormatter/">newer version</a> if this formatter does not process your code properly</h2>
<h2>VHDL Beautifier, Formatter</h2>
<h4>Beautify and format your VHDL code online</h4>
<p>
Proper formatting makes code easier to read and understand.<br>
Please make a backup before you replace your code!<br>
<a href="https://github.com/g2384/g2384.github.io/issues" target="_blank">Report bugs if your code is not properly formatted, please provide sample code which causes the failure</a>
</p>
<div id="lastModified"></div>
<textarea id="in" rows="10" wrap="off"></textarea><br>
<form id="keyword">Keyword Case: 
<label><input type="radio" name="keywordcase" value="UpperCase" checked="checked">UPPERCASE</label> 
| <label><input type="radio" name="keywordcase" value="LowerCase">lowercase</label> 
| <label><input type="radio" name="keywordcase" value="DefaultCase">Default</label></form>
<label><input type="checkbox" id="no_format" onclick="noFormat()">Only highlight, don't format</label><br>
<label><input type="checkbox" checked="checked" id="new_line">New line after THEN, semicolon ";"</label><br>
<label><input type="checkbox" id="remove_comments">Remove commments</label>
 | <label><input type="checkbox" id="remove_lines">Remove blank lines</label>
 | <label><input type="checkbox" id="remove_report">Remove REPORT</label><br>
<label><input type="checkbox" id="check_alias">Check ALIAS (every long name is replaced with ALIAS)</label><br>
<label><input type="checkbox" id="sign_align">Align signs in PORT()</label>
 | <label><input type="checkbox" id="new_line_after_port">New line after PORT & GENERIC</label><br>
<label><input type="checkbox" id="sign_align_all">Align signs in all places</label><br>
<label><input type="checkbox" id="use_space">Customise Indentation (tab is \t): </label> <input type="text" id="cust_indent" size="8" onKeyUp="indent_decode()" value="    "/> (<span id="indent_s">four blankspace</span>)<br>
<label><input type="checkbox" id="compress">! EVIL - compress VHDL (\r\n, comments will be removed)</label><br>
<label><input type="checkbox" id="mix_letter">! EVIL - unreadable (mix upper/lower-case letters)</label><br>
<input type="button" class="btn" onclick="f()" value="start"/>
<span class="show"><input type="button" class="btn " id="selectAll" value="Select All" onclick="selectText(document.getElementById('vhdl'))"/> 
<label><input type="checkbox" onclick="wordWrap()" id="">Word wrap</label></span><br>
<pre id="result"><code class="vhdl" id="vhdl">
<font style="background-color:#9D9D9D; color:#fff"> output sample </font>

<span class="hljs-keyword">LIBRARY</span> IEEE; <span class="hljs-comment">-- declare the library</span>
<span class="hljs-keyword">USE</span> IEEE.std_logic_1164.<span class="hljs-keyword">ALL</span>;
<span class="hljs-keyword">USE</span> IEEE.std_logic_arith.<span class="hljs-keyword">ALL</span>;
<font style="background-color:#9D9D9D; color:#fff"> (All reserved words are in capital) </font>
<font style="background-color:#9D9D9D; color:#fff"> (All indents are in the right place) </font>
<span class="hljs-comment">---------------------------------------------------------------</span>

<span class="hljs-keyword">ENTITY</span> example <span class="hljs-keyword">IS</span>
	<span class="hljs-keyword">PORT</span> (
		rst                   : <span class="hljs-keyword">IN</span> <span class="hljs-typename">std_logic</span>;
		clk                   : <span class="hljs-keyword">IN</span> <span class="hljs-typename">std_logic</span>;
		example_of_long_words : <span class="hljs-keyword">OUT</span> <span class="hljs-typename">std_logic_vector</span>(<span class="hljs-number">3</span> <span class="hljs-keyword">DOWNTO</span> <span class="hljs-number">0</span>)
		<font style="background-color:#9D9D9D; color:#fff"> (<strong>Align signs in PORT()</strong> aligns these colons) </font>
	);
<span class="hljs-keyword">END</span> example;

<span class="hljs-keyword">ARCHITECTURE</span> EXA <span class="hljs-keyword">OF</span> example <span class="hljs-keyword">IS</span>
	<span class="hljs-keyword">ALIAS</span> slv <span class="hljs-keyword">IS</span> <span class="hljs-typename">std_logic_vector</span>;
	<span class="hljs-keyword">SUBTYPE</span> bit4 <span class="hljs-keyword">IS</span> slv(<span class="hljs-number">3</span> <span class="hljs-keyword">DOWNTO</span> <span class="hljs-number">0</span>); <font style="background-color:#9D9D9D; color:#fff"> (<strong>Check ALIAS</strong> replaces all "<strong>std_logic_vector</strong>" with "<strong>slv</strong>") </font>
	 
<span class="hljs-keyword">BEGIN</span>
	<del><span class="hljs-keyword">REPORT</span> <span class="hljs-string">"Hello World"</span></del>; <font style="background-color:#9D9D9D; color:#fff"> (Remove REPORT) </font>
	 
	stages : <span class="hljs-keyword">PROCESS</span> (rst, clk)
	<span class="hljs-keyword">BEGIN</span>
		 
		<span class="hljs-keyword">IF</span> (rst = <span class="hljs-literal">'0'</span>) <span class="hljs-keyword">THEN</span>
			<span class="hljs-keyword">CASE</span> bit4 <span class="hljs-keyword">IS</span>
				<span class="hljs-keyword">WHEN</span> <span class="hljs-string">"0000"</span> =&gt; bit4 &lt;= <span class="hljs-string">"0001"</span>;
				<span class="hljs-keyword">WHEN</span> <span class="hljs-string">"0001"</span> =&gt; bit4 &lt;= <span class="hljs-string">"0100"</span>;
				<span class="hljs-keyword">WHEN</span> <span class="hljs-string">"0010"</span> =&gt; bit4 &lt;= <span class="hljs-string">"0010"</span>;
				<span class="hljs-keyword">WHEN</span> <span class="hljs-string">"0100"</span> =&gt; bit4 &lt;= <span class="hljs-string">"0000"</span>;
				<span class="hljs-keyword">WHEN</span> <span class="hljs-keyword">OTHERS</span> =&gt; 
					<del><span class="hljs-keyword">REPORT</span> <span class="hljs-string">"Are there any more cases?"</span></del>; <font style="background-color:#9D9D9D; color:#fff"> (Remove REPORT) </font>
			<span class="hljs-keyword">END</span> <span class="hljs-keyword">CASE</span>;
		<span class="hljs-keyword">ELSIF</span> (clk<span class="hljs-attribute">'event</span> <span class="hljs-keyword">AND</span> clk = <span class="hljs-literal">'1'</span>) <span class="hljs-keyword">THEN</span>
			<span class="hljs-keyword">IF</span> (bit4 = '<span class="hljs-number">0111</span>') <span class="hljs-keyword">THEN</span>
				bit4 &lt;= <span class="hljs-string">"0000"</span>;
			<span class="hljs-keyword">ELSE</span>
				bit4 &lt;= <span class="hljs-string">"1111"</span>;
			<span class="hljs-keyword">END</span> <span class="hljs-keyword">IF</span>;
			<del><span class="hljs-comment">-- Sample comments 1;</span> </del> 
			<del> <span class="hljs-comment">-- Sample comments 2;</span></del>  <font style="background-color:#9D9D9D; color:#fff"> (Remove comments) </font>
		<span class="hljs-keyword">END</span> <span class="hljs-keyword">IF</span>;
		 
	<span class="hljs-keyword">END</span> <span class="hljs-keyword">PROCESS</span>;
<span class="hljs-keyword">END</span> EXA;</code></pre>
<script>
isTesting = false;
showUnitTests = window.location.href.indexOf("http") < 0;

function fetchHeader(url, wch) {
    try {
        var req=new XMLHttpRequest();
        req.open("HEAD", url, false);
        req.send(null);
        if(req.status== 200){
            return req.getResponseHeader(wch);
        }
        else return false;
    } catch(e) {
        return "";
    }
}

lastModifiedDate = fetchHeader(location.href,'Last-Modified');
if(lastModifiedDate != ""){
    document.getElementById("lastModified").innerHTML = "<p>Last modified: " + lastModifiedDate + "</p>";
}

String.prototype.regexIndexOf = function(pattern, startIndex) {
    startIndex = startIndex || 0;
    var searchResult = this.substr(startIndex).search(pattern);
    return (-1 === searchResult) ? -1 : searchResult + startIndex;
}
String.prototype.regexLastIndexOf = function(pattern, startIndex) {
    startIndex = startIndex === undefined ? this.length : startIndex;
    var searchResult = this.substr(0, startIndex).reverse().regexIndexOf(pattern, 0);
    return (-1 === searchResult) ? -1 : this.length - ++searchResult;
}
String.prototype.reverse = function() {
    return this.split('').reverse().join('');
}

function wordWrap() {
    var d = document.getElementById("result");
    if (d.className.length == "") {
        d.className = "wordwrap";
    } else {
        d.className = "";
    }
}

function noFormat() {
    var t = !(document.getElementById("remove_comments").disabled);
    document.getElementById("remove_comments").disabled = t;
    document.getElementById("remove_lines").disabled = t;
    document.getElementById("remove_report").disabled = t;
    document.getElementById("check_alias").disabled = t;
    document.getElementById("sign_align").disabled = t;
    document.getElementById("sign_align_all").disabled = t;
    document.getElementById("new_line_after_port").disabled = t;
    document.getElementById("new_line").disabled = t;
    document.getElementById("use_space").disabled = t;
    document.getElementById("compress").disabled = t;
    document.getElementById("mix_letter").disabled = t;
    var limit = document.getElementById("keyword").elements.length;
    for (i = 0; i < limit; i++) {
        document.getElementById("keyword").elements[i].disabled = t;
    }
}

function indent_decode() {
    var custom_indent = document.getElementById("cust_indent").value;
    custom_indent = custom_indent.replace(/\\t/g, "	");
    var count = [" & one ", " & two ", " & three ", " & four ", " & five ", " & six ", " & seven ", " & eight ", " & many "];
    var p = custom_indent.split("");
    var s = "";
    var a = 0;
    for (var i = 0; i < p.length; i++) {
        var c = custom_indent.substr(i, 1);
        if (c == custom_indent.substr(i + 1, 1)) {
            a++;
        } else {
            switch (c) {
                case " ":
                    c = "blankspace";
                    break;
                case "\t":
                    c = "tab";
            }
            a = a > 8 ? 8 : a;
            s += count[a] + c;
            a = 0;
        }
    }
    if (s.length < 0) {
        switch (c) {
            case " ":
                c = "blankspace";
                break;
            case "\t":
                c = "tab";
        }
        a = a > 8 ? 8 : a;
        s = count[a] + c;
    }
    s = s.replace(/^ & /, "")

    document.getElementById("indent_s").innerHTML = s;
}

function Compress(input) {
    input = input.replace(/\r\n/g, '');
    input = input.replace(/[\t ]+/g, ' ');
    input = input.replace(/[ ]?([&=:\-<>\+|])[ ]?/g, '$1');
    return input;
}

function MixLetters(input) {
    arr = input.split("");
    for (var k = 0; k < arr.length; k++) {
        if (arr[k] === arr[k].toUpperCase() && Math.random() > 0.5) {
            arr[k] = arr[k].toLowerCase();
        } else if (Math.random() > 0.5) {
            arr[k] = arr[k].toUpperCase();
        }
    }
    return arr.join("");
}

function EscapeComments(arr, comments, comments_i) {
    for (var i = 0; i < arr.length; i++) {
        var n = arr[i].regexIndexOf(/[a-zA-Z0-9\(\&\)%_\+'"|]/);
        var p = arr[i].indexOf("--");
        if (n < p && n >= 0) {
            comments.push(arr[i].substr(p));
            arr[i] = arr[i].substr(n, p - n) + "@@comments" + (comments_i++);
        } else if ((n > p && p >= 0) || (n < 0 && p >= 0)) {
            comments.push(arr[i].substr(p));
            arr[i] = "@@comments" + (comments_i++);
        } else {
            n = n < 0 ? 0 : n;
            arr[i] = arr[i].substr(n);
        }
    }
    return comments_i
}

function SetKeywordCase(input, keywordcase, keyword, typename) {
    if (keywordcase == "LowerCase") {
        for (var k = 0; k < keyword.length; k++) {
            keyword[k] = keyword[k].toLowerCase();
        }
        for (var k = 0; k < typename.length; k++) {
            typename[k] = typename[k].toLowerCase();
        }
    } else if (keywordcase == "DefaultCase") {
        for (var k = 0; k < keyword.length; k++) {
            keyword[k] = keyword[k].charAt(0) + keyword[k].slice(1).toLowerCase();
        }
        for (var k = 0; k < typename.length; k++) {
            typename[k] = typename[k].charAt(0) + typename[k].slice(1).toLowerCase();
        }
    }
    if (keywordcase != "UpperCase") {
        for (var k = 0; k < keyword.length; k++) {
            input = input.replace(new RegExp("([^a-zA-Z0-9_@]|^)" + keyword[k] + "([^a-zA-Z0-9_]|$)", 'gi'), "$1" + keyword[k] + "$2");
        }
        for (var k = 0; k < typename.length; k++) {
            input = input.replace(new RegExp("([^a-zA-Z0-9_@]|^)" + typename[k] + "([^a-zA-Z0-9_]|$)", 'gi'), "$1" + typename[k] + "$2");
        }
    }
    return input;
}

function f() {
    var input = document.getElementById("in").value;
    var no_format = document.getElementById("no_format").checked;
    if (no_format) {
        document.getElementById("vhdl").innerHTML = input;
        document.querySelector(".show").style.display = "inline-block";
        hljs.highlightBlock(document.getElementById("vhdl"));
        return;
    }
    var remove_comments = document.getElementById("remove_comments").checked;
    var remove_lines = document.getElementById("remove_lines").checked;
    var remove_report = document.getElementById("remove_report").checked;
    var check_alias = document.getElementById("check_alias").checked;
    var sign_align = document.getElementById("sign_align").checked;
    var sign_align_all = document.getElementById("sign_align_all").checked;
    var new_line_after_port = document.getElementById("new_line_after_port").checked;
    var new_line = document.getElementById("new_line").checked;
    var use_space = document.getElementById("use_space").checked;
    var compress = document.getElementById("compress").checked;
    var cust_indent = document.getElementById("cust_indent").value;
    var keywordcase = document.getElementById("keyword").elements.namedItem("keywordcase").value;
    var mix_letter = document.getElementById("mix_letter").checked;
    if (compress) {
        remove_comments = true;
    }

    indentation = "\t";
    if (use_space) {
        cust_indent = cust_indent.replace(/\\t/, "	");
        indentation = cust_indent;
    }

    input = beautify(input, no_format, remove_comments, remove_report, check_alias, sign_align, sign_align_all, new_line, keywordcase, indentation, new_line_after_port);

    if (remove_lines) {
        input = input.replace(/(\r\n)*[ \t]*\r\n/g, '\r\n');
    }

    if (compress) {
        input = Compress(input);
    }
	
    if (mix_letter) {
        input = MixLetters(input);
    }
	
    document.getElementById("vhdl").innerHTML = input;
    document.querySelector(".show").style.display = "inline-block";
    hljs.highlightBlock(document.getElementById("vhdl"));
}

function beautify(input, no_format, remove_comments, remove_report, check_alias, sign_align, sign_align_all, new_line, keywordcase, indentation, new_line_after_port) {
    keyword = ["ABS", "ACCESS", "AFTER", "ALIAS", "ALL", "AND", "ARCHITECTURE", "ARRAY", "ASSERT", "ATTRIBUTE", "BEGIN", "BLOCK", "BODY", "BUFFER", "BUS", "CASE", "COMPONENT", "CONFIGURATION", "CONSTANT", "CONTEXT", "COVER", "DISCONNECT", "DOWNTO", "DEFAULT", "ELSE", "ELSIF", "END", "ENTITY", "EXIT", "FAIRNESS", "FILE", "FOR", "FORCE", "FUNCTION", "GENERATE", "GENERIC", "GROUP", "GUARDED", "IF", "IMPURE", "IN", "INERTIAL", "INOUT", "IS", "LABEL", "LIBRARY", "LINKAGE", "LITERAL", "LOOP", "MAP", "MOD", "NAND", "NEW", "NEXT", "NOR", "NOT", "NULL", "OF", "ON", "OPEN", "OR", "OTHERS", "OUT", "PACKAGE", "PORT", "POSTPONED", "PROCEDURE", "PROCESS", "PROPERTY", "PROTECTED", "PURE", "RANGE", "RECORD", "REGISTER", "REJECT", "RELEASE", "REM", "REPORT", "RESTRICT", "RESTRICT_GUARANTEE", "RETURN", "ROL", "ROR", "SELECT", "SEQUENCE", "SEVERITY", "SHARED", "SIGNAL", "SLA", "SLL", "SRA", "SRL", "STRONG", "SUBTYPE", "THEN", "TO", "TRANSPORT", "TYPE", "UNAFFECTED", "UNITS", "UNTIL", "USE", "VARIABLE", "VMODE", "VPROP", "VUNIT", "WAIT", "WHEN", "WHILE", "WITH", "XNOR", "XOR"];
    var typename = ["BOOLEAN", "BIT", "CHARACTER", "INTEGER", "TIME", "NATURAL", "POSITIVE", "STRING"];
    input = input.replace(/(?:\r\n|\r|\n)/g, '\r\n');
    input = input.replace(/ \r\n/g, '\r\n');
    input = input.replace(/\r\n\r\n\r\n/g, '\r\n');
    input = input.replace(/[\t ]+/g, ' ');
    input = input.replace(/\([\t ]+/g, '\(');
    input = input.replace(/[ ]+;/g, ';');
    input = input.replace(/:[ ]*(PROCESS|ENTITY)/gi, ':$1');

    var arr = input.split("\r\n");
    var comments = [],
        comments_i = 0;
    var quotes = [],
        quotes_i = 0;
    var singleline = [],
        singleline_i = 0;
    var align = [],
        align_max = [],
        align_i1 = 0,
        align_i = 0;
    var str = "",
        str1 = "";
    var k = [],
        p = 0;
    var n = 0,
        j = 0;
    var tab_n = 0,
        str_len = 0,
        port_s = "";
    var back_tab = false,
        forward_tab = false,
        need_semi = false,
        semi_pos = 0,
        begin_b = true,
        port_b = false;
    comments_i = EscapeComments(arr, comments, comments_i);
    input = arr.join("\r\n");

    for (var k = 0; k < keyword.length; k++) {
        input = input.replace(new RegExp("([^a-zA-Z0-9_]|^)" + keyword[k] + "([^a-zA-Z0-9_]|$)", 'gi'), "$1" + keyword[k] + "$2");
    }
    for (var k = 0; k < typename.length; k++) {
        input = input.replace(new RegExp("([^a-zA-Z0-9_]|^)" + typename[k] + "([^a-zA-Z0-9_]|$)", 'gi'), "$1" + typename[k] + "$2");
    }
    if (remove_comments) {
        input = input.replace(/@@comments[0-9]+/g, '');
    }
    input = input.replace(/(PORT|PROCESS|GENERIC)[\s]*\(/g, '$1 (');
    if (new_line) {
        input = input.replace(/(;|THEN)[ ]?([a-zA-Z])/g, '$1\r\n$2');
    }
    arr = input.split("\r\n");
    var l = arr.length;
    var before_begin = true;
    for (i = 0; i < l; i++) {
        k = arr[i].match(/"([^"]+)"/g);
        if (k != null) {
            var u = k.length;
            for (var j = 0; j < u; j++) {
                arr[i] = arr[i].replace(k[j], "@@quotes" + quotes_i);
                quotes[quotes_i++] = k[j];
            }
        }

        if (arr[i].indexOf("BEGIN") >= 0) {
            before_begin = false;
        }

        if (remove_report) {
            n = arr[i].indexOf("REPORT ");
            p = arr[i].indexOf(";");
            if (need_semi) {
                arr[i] = '';
                if (p >= 0) {
                    need_semi = false;
                }
            }
            if (n >= 0) {
                arr[i] = '';
                if (p < 0) {
                    need_semi = true;
                }
            } else if (n < 0) {
                n = arr[i].indexOf("ASSERT ");
                if (n >= 0) {
                    arr[i] = '';
                    if (p < 0) {
                        need_semi = true;
                    }
                }
            }
        }

        if (arr[i].match(/FUNCTION|PROCEDURE/) != null) {
            arr[i] = arr[i].replace(/;/g, '@@semicolon');
        }
        if (port_s) {
            port_s += arr[i];
            var k_port = port_s.split("(").length;
            if (k_port == port_s.split(")").length) {
                arr[i] = arr[i] + "@@end";
                port_s = "";
                port_b = false;
            }
        }
        if ((!port_b && arr[i].regexIndexOf(/(\s|\(|^)(PORT|GENERIC|PROCESS|PROCEDURE)(\s|\(|$)/) >= 0) || (arr[i].regexIndexOf(/:[ ]?=[ ]?\(/) >= 0 && before_begin)) {
            port_b = true;
            port_s = arr[i];
            var k_port = port_s.split("(").length;
            if (k_port == 1) {
                port_b = false;
                port_s = "";
            } else if (k_port == port_s.split(")").length) {
                port_s = "";
                port_b = false;
                arr[i] = arr[i] + "@@singleend";
            } else {
                arr[i] = arr[i].replace(/(PORT|GENERIC|PROCEDURE)([a-z0-9A-Z_ ]+)\(([a-zA-Z0-9_\(\) ]+)/, '$1$2(\r\n$3');
            }
        }
        if (!new_line) {
            if (arr[i].regexIndexOf(/(;|THEN)[ a-z0-9]+[a-z0-9]+/) >= 0) {
                singleline[singleline_i] = arr[i];
                arr[i] = "@@singleline" + singleline_i++;
            }
        }
    }
    input = arr.join("\r\n");
    input = input.replace(/([a-zA-Z0-9\); ])\);(@@comments[0-9]+)?@@end/g, '$1\r\n);$2@@end');
    input = input.replace(/[ ]?([&=:\-<>\+|\*])[ ]?/g, ' $1 ');
    input = input.replace(/[ ]?([,])[ ]?/g, '$1 ');
    input = input.replace(/[ ]?(['"])(THEN)/g, '$1 $2');
    input = input.replace(/[ ]?(\?)?[ ]?(<|:|>|\/)?[ ]+(=)?[ ]?/g, ' $1$2$3 ');
    input = input.replace(/(IF)[ ]?([\(\)])/g, '$1 $2');
    input = input.replace(/([\(\)])[ ]?(THEN)/gi, '$1 $2');
    input = input.replace(/(^|[\(\)])[ ]?(AND|OR|XOR|XNOR)[ ]*([\(])/g, '$1 $2 $3');
    input = input.replace(/ ([\-\*\/=+<>])[ ]*([\-\*\/=+<>]) /g, " $1$2 ");
    input = input.replace(/\r\n[ \t]+--\r\n/g, "\r\n");
    input = input.replace(/[ ]+/g, ' ');
    input = input.replace(/\r\n\r\n\r\n/g, '\r\n');
    input = input.replace(/[\r\n\s]+$/g, '');
    input = input.replace(/[ \t]+\)/g, ')');
    //if (remove_lines) {
    //    input = input.replace(/(\r\n)*[ \t]*\r\n/g, '\r\n');
    //}
    var matches = input.match(/'([a-zA-Z]+)\s/g);
    if (matches != null) {
        for (var k = 0; k < matches.length; k++) {
            input = input.replace(matches[k], matches[k].toUpperCase());
        }
    }
    input = input.replace(/(MAP)[ \r\n]+\(/g, '$1(');
    input = input.replace(/(;|THEN)[ ]?(@@comments[0-9]+)([a-zA-Z])/g, '$1 $2\r\n$3');
    input = input.replace(/[\r\n ]+RETURN/g, ' RETURN');
    input = input.replace(/BEGIN[\r\n ]+/g, 'BEGIN\r\n');
    input = input.replace(/ (PORT|GENERIC) /g, '\r\n$1 ');
    if (new_line) {
        input = input.replace(/ELSE[ ]+([\w]+)/, "ELSE\r\n$1");
    }
    if (check_alias) {
        var alias = [],
            subarr = [],
            o = 0,
            p = 0,
            p2 = 0,
            l2 = 0,
            i2 = 0;
        arr = input.split("ARCHITECTURE ");
        l = arr.length;
        for (i = 0; i < l; i++) {
            subarr = arr[i].split("ALIAS ");
            l2 = subarr.length;
            if (l2 > 1) {
                var o;
                for (i2 = 1; i2 < l2; i2++) {
                    o = subarr[i2].indexOf(";", n);
                    str = subarr[i2].substring(0, o);
                    alias[p2++] = str.split(" IS ");
                }
                i2--;
                var str2 = subarr[i2].substr(o);
                for (p = 0; p < p2; p++) {
                    var reg = new RegExp(alias[p][1], 'gi');
                    str2 = str2.replace(reg, alias[p][0]);
                }
                subarr[i2] = subarr[i2].substring(0, o) + str2;
            }
            arr[i] = subarr.join("ALIAS ");
        }
        input = arr.join("ARCHITECTURE ");
    }
    arr = input.split("\r\n");
    l = arr.length;
    var signAlignPos = "";
    var if_b = 0,
        white_space = "",
        case_b = false,
        case_n = 0,
        procfun_b = false,
        semi_b = false,
        set_false = false,
        entity_b = false,
        then_b = false,
        conditional_b = false,
        generic_map_b = false,
        architecture_begin_b = false,
        process_begin_b = false,
        case_indent = [0, 0, 0, 0, 0, 0, 0];
    var align_groups = [],
        align_groups_max = [],
        lastAlignedSign = "",
        current_align_group = 0,
        aligned_group_starts = 0;
    var indent_start = [];
    for (i = 0; i < l; i++) {
        str = arr[i];
        str_len = str.length;
        if (str.replace(/[ \-\t]*/, "").length > 0) {
            var first_word = str.split(/[^\w]/)[0];
            var indent_start_last = indent_start.length == 0? 0 : indent_start[indent_start.length - 1];
            if (then_b) {
                arr[i] = " " + arr[i];
                if (str.indexOf(" THEN") >= 0) {
                    then_b = false;
                    back_tab = true;
                }
            }
            arr[i] = white_space + arr[i];
            if (first_word == "ELSIF") {
                tab_n = indent_start_last - 1;
                indent_start.pop();
                back_tab = true;
            } else if (str.indexOf("END CASE") == 0) {
                indent_start.pop();
                case_n--;
                tab_n = indent_start[indent_start.length - 1];
            } else if (first_word == "END") {
                tab_n = indent_start_last - 1;
                indent_start.pop();
                if (str.indexOf("END IF") == 0) {
                    if_b--;
                }
                if (i == l - 1) {
                    tab_n = 1;
                }
            } else if (first_word == "ELSE" && if_b) {
                tab_n = indent_start_last - 1;
                indent_start.pop();
                back_tab = true;
            } else if (case_n) {
                if (first_word == "WHEN") {
                    tab_n = case_indent[case_n - 1];
                    //back_tab = true;
                }
            } else if (first_word == "BEGIN") {
                if (begin_b) {
                    if (architecture_begin_b) {
                        tab_n = indent_start_last - 1;
                        architecture_begin_b = false;
                    }else if (process_begin_b) {
                        tab_n = indent_start_last - 1;
                        process_begin_b = false;
                    } else {
                        tab_n = indent_start_last;
                        indent_start.push(tab_n + 1);
                    }
                    //indent_start.pop();
                    back_tab = true;
                    begin_b = false;
                    if (procfun_b) {
                        tab_n++;
                        indent_start.push(tab_n);
                        begin_b = true;
                    }
                } else {
                    back_tab = true;
                }
            } else if (first_word == "PROCESS") {
                begin_b = true;
            } else if (str.indexOf(": PROCESS") >= 0) {
                back_tab = true;
                begin_b = true;
                process_begin_b = true;
            } else if (str.indexOf(": ENTITY") >= 0) {
                back_tab = true;
                entity_b = true;
            } else if (str.indexOf("PROCEDURE ") >= 0) {
                back_tab = true;
                begin_b = true;
            }
            if (port_b && str.indexOf("@@") < 0 && arr[i + 1].indexOf("@@") < 0) {
                if (signAlignPos == ":") {
                    if (str.indexOf(';') < 0) {
                        arr[i] += arr[i + 1];
                        arr[i + 1] = '@@removeline';
                    }
                } else if (signAlignPos == "=>") {
                    if (str.indexOf(',') < 0) {
                        arr[i] += arr[i + 1];
                        arr[i + 1] = '@@removeline';
                    }
                }
            }
            if (str.indexOf("PORT MAP") >= 0) {
                back_tab = true;
                port_b = true;
                if (str.indexOf(");") < 0) {
                    align_i1 = align_i;
                    var t = str.indexOf("=>");
                    if (t >= 0) {
                        signAlignPos = "=>";
                    } else {
                        t = arr[i + 1].indexOf("=>");
                        if (t >= 0) {
                            signAlignPos = "=>";
                        }
                    }
                } else {
                    signAlignPos = "";
                }
            } else if (str.indexOf("GENERIC MAP") >= 0) {
                tab_n++;
                indent_start.push(tab_n);
                generic_map_b = true;
                if (!begin_b) {
                    back_tab = false;
                }
            } else if (str.indexOf("PORT (") >= 0 && begin_b) {
                back_tab = true;
                port_b = true;
                t = str.indexOf(":");
                if (str.indexOf(");") < 0) {
                    align_i1 = align_i;
                    if (t >= 0) {
                        signAlignPos = ":";
                    } else {
                        t = arr[i + 1].indexOf(":");
                        if (t >= 0) {
                            signAlignPos = ":";
                        }
                    }
                } else {
                    signAlignPos = "";
                }
            }
            if (set_false) {
                procfun_b = false;
                set_false = false;
            }
            if (str.indexOf("(") >= 0) {
                if (str.indexOf("PROCEDURE") >= 0 || str.indexOf("FUNCTION") >= 0) {
                    procfun_b = true;
                    back_tab = true;
                }
                if ((str.indexOf("GENERIC") >= 0 || str.indexOf(":= (") >= 0 || str.regexIndexOf(/PROCEDURE[a-zA-Z0-9_ ]+\(/) >= 0) && begin_b) {
                    port_b = true;
                    back_tab = true;
                }
            } else if (first_word == "FUNCTION") {
                back_tab = true;
                begin_b = true;
            }
            if (str.indexOf("@@singleend") >= 0) {
                back_tab = false;
                port_b = false;
                if (!begin_b) {
                    forward_tab = true;
                }
            } else if (str.indexOf("@@end") >= 0 && port_b) {
                port_b = false;
                indent_start.pop();
                tab_n = indent_start[indent_start.length - 1];
                if (entity_b) {
                    forward_tab = true;
                }
                if (generic_map_b) {
                    forward_tab = true;
                    generic_map_b = false;
                }
            }
            if (sign_align_all) {
                var alignedSigns = [":", "<=", "=>"];
                for (var currentSign = 0; currentSign < alignedSigns.length; currentSign++) {
                    if (str.indexOf(alignedSigns[currentSign]) > 0) {
                        var char_before_sign = str.split(alignedSigns[currentSign])[0];
                        var char_before_sign_length = char_before_sign.length;
                        align_groups.push(char_before_sign_length);
                        align_groups_max.push(char_before_sign_length);
                        if (alignedSigns[currentSign] == lastAlignedSign) {
                            if (align_groups_max[current_align_group - 1] < char_before_sign_length) {
                                for (var k = aligned_group_starts; k <= current_align_group; k++) {
                                    align_groups_max[k] = char_before_sign_length;
                                }
                            } else {
                                align_groups_max[current_align_group] = align_groups_max[current_align_group - 1];
                            }
                        } else {
                            aligned_group_starts = current_align_group;
                        }
                        arr[i] = char_before_sign + "@@alignall" + (current_align_group++) + str.substring(char_before_sign.length, arr[i].length);
                        lastAlignedSign = alignedSigns[currentSign];
                        break;
                    }
                }
                if (currentSign == alignedSigns.length) {
                    lastAlignedSign = "";
                }
            } else if (sign_align) {
                if (port_b && signAlignPos != "") {
                    if (str.indexOf(signAlignPos) >= 0) {
                        var a1 = arr[i].split(signAlignPos);
                        var l1 = a1[0].length;
                        if (align_i >= 0 && align_i > align_i1) {
                            align_max[align_i] = align_max[align_i - 1];
                        } else {
                            align_max[align_i] = l1;
                        }
                        if (align_i > align_i1 && align_max[align_i] < l1) {
                            for (var k = align_i1; k <= align_i; k++) {
                                align_max[k] = l1;
                            }
                        }
                        align[align_i] = l1;
                        arr[i] = a1[0] + "@@align" + (align_i++) + signAlignPos + arr[i].substring(l1 + signAlignPos.length, arr[i].length);
                    }
                }
            }
            tab_n = tab_n < 1 ? 1 : tab_n;
            if (str_len) {
                if (isTesting) {
                    console.log(tab_n, arr[i], indent_start);
                }
                arr[i] = (Array(tab_n).join(indentation)) + arr[i]; //indent
                if (new_line_after_port) {
                    if (str.indexOf('@@singleend') < 0) {
                        arr[i] = arr[i].replace(/(PORT|GENERIC)([ \w]*)\(/, "$1$2\r\n" + (Array(tab_n).join(indentation)) + "(");
                    }
                }
            }
            if (back_tab) {
                tab_n++;
                indent_start.push(tab_n);
                back_tab = false;
            }
            if (forward_tab) {
                tab_n = indent_start_last;
                indent_start.pop();
                forward_tab = false;
            }

            if (conditional_b && str.indexOf(";") >= 0) {
                conditional_b = false;
                white_space = "";
            } else if (str.indexOf(";") >= 0 && semi_b) {
                semi_b = false;
                tab_n = indent_start_last;
                indent_start.pop();
            } else if (!semi_b && str.indexOf(";") < 0 && !port_b) {
                if (!conditional_b) {
                    if (str.indexOf("WHEN") > 3 && str.indexOf("<=") > 1) {
                        conditional_b = true;
                        white_space = (Array(str.indexOf("= ") + 3).join(" "));
                    } else if (first_word == "WHEN" && i + 1 < arr.length && arr[i + 1].indexOf("WHEN") < 0) {
                        tab_n = indent_start_last + 1;
                    } else if (str.indexOf("=>") < 0 && ((str.indexOf("@@quotes") >= 0 && str.indexOf("= @@quotes") < 0 && str.indexOf("IF") < 0) || (str.indexOf("<=") > 0 && str.indexOf("IF") < 0 && str.indexOf("THEN") < 0))) {
                        tab_n++;
                        indent_start.push(tab_n);
                        semi_b = true;
                    }
                }
            }

            if (first_word == "ENTITY") {
                tab_n++;
                indent_start.push(tab_n);
            } else if (",RECORD,PACKAGE,FOR,COMPONENT,CONFIGURATION,".indexOf("," + first_word + ",") >= 0) {
                tab_n++;
                indent_start.push(tab_n);
            } else if (str.indexOf(": FOR ") >= 0) {
                tab_n++;
                indent_start.push(tab_n);
            } else if (first_word == "CASE" || str.indexOf(": CASE") >= 0) {
                tab_n++;
                indent_start.push(tab_n);
                case_indent[case_n] = tab_n;
                case_n++;
            } else if (first_word == "ARCHITECTURE") {
                tab_n++;
                indent_start.push(tab_n);
                begin_b = true;
                architecture_begin_b = true;
            } else if (first_word == "IF") {
                if_b++;
                tab_n++;
                indent_start.push(tab_n);
                if (str.indexOf(" THEN") < 0) {
                    then_b = true;
                    tab_n = indent_start_last;
                    //indent_start.pop();
                }
            }
            if (procfun_b) {
                if (str.regexIndexOf(/(\))|(RETURN [A-Za-z0-9 ]+)[\r\n ]+IS/) >= 0) {
                    tab_n = indent_start_last;
                    indent_start.pop();
                    set_false = true;
                }
            }
        }
    }

    input = arr.join("\r\n");
    input = input.replace(/[\t]*@@removeline\r\n/g, '');

    p = input.indexOf('PROCESS');
    while (p >= 0) {
        nextBracket = input.indexOf('(', p);
        nextNewLine = input.indexOf('\r\n', p);
        nextCloseBracket = input.indexOf(')', nextBracket);
        if (nextBracket < nextNewLine && nextCloseBracket > nextNewLine) {
            processArray = input.substring(p, nextCloseBracket).split('\r\n');
            if (indentation.replace(/[ ]+/g, '').length == 0) {
                for (var i = 1; i < processArray.length; i++) {
                    processArray[i] = (Array(nextBracket - p + 2).join(' ')) + processArray[i];
                }
            } else {
                for (var i = 1; i < processArray.length; i++) {
                    processArray[i] = indentation + processArray[i];
                }
            }
            input = input.substring(0, p) + processArray.join('\r\n') + input.substring(nextCloseBracket, input.length);
            p = input.regexIndexOf('PROCESS[ ]+\\(', nextCloseBracket);
        } else {
            p = input.indexOf('PROCESS[ ]+\\(', p + 7);
        }
    }

    input = SetKeywordCase(input, keywordcase, keyword, typename);

    if (sign_align_all) {
        for (var k = 0; k < current_align_group; k++) {
            input = input.replace("@@alignall" + k, Array((align_groups_max[k] - align_groups[k] + 1)).join(" "));
        }
    }

    if (sign_align) {
        for (var k = 0; k < align_i; k++) {
            input = input.replace("@@align" + k, Array((align_max[k] - align[k] + 2)).join(" "));
        }
    }

    for (var k = 0; k < quotes_i; k++) {
        input = input.replace("@@quotes" + k, quotes[k]);
    }

    for (var k = 0; k < singleline_i; k++) {
        input = input.replace("@@singleline" + k, singleline[k]);
    }

    for (var k = 0; k < comments_i; k++) {
        input = input.replace("@@comments" + k, comments[k]);
    }

    input = input.replace(/@@semicolon/g, ";");
    input = input.replace(/@@[a-z]+/g, "");
    return input;
}

function UnitTest() {
    if (!isTesting && !showUnitTests) {
        return;
    }
    no_format = false;
    remove_comments = false;
    remove_report = false;
    check_alias = false;
    sign_align = false;
    sign_align_all = false;
    new_line = true;
	new_line_after_port = false;
    keywordcase = "uppercase";
    indentation = "    ";
    input = "architecture TB of TB_CPU is\r\n    component CPU_IF\r\n    port   -- port list\r\n    end component;\r\n    signal CPU_DATA_VALID: std_ulogic;\r\n    signal CLK, RESET: std_ulogic := '0';\r\n    constant PERIOD : time := 10 ns;\r\n    constant MAX_SIM: time := 50 * PERIOD;\r\n    begin\r\n    -- concurrent statements\r\n    end TB;"
    expected = "ARCHITECTURE TB OF TB_CPU IS\r\n    COMPONENT CPU_IF\r\n        PORT -- port list\r\n    END COMPONENT;\r\n    SIGNAL CPU_DATA_VALID : std_ulogic;\r\n    SIGNAL CLK, RESET : std_ulogic := '0';\r\n    CONSTANT PERIOD : TIME := 10 ns;\r\n    CONSTANT MAX_SIM : TIME := 50 * PERIOD;\r\nBEGIN\r\n    -- concurrent statements\r\nEND TB;";
    actual = beautify(input, no_format, remove_comments, remove_report, check_alias, sign_align, sign_align_all, new_line, keywordcase, indentation, new_line_after_port);
    console.log("General", actual == expected);

    expected = "ARCHITECTURE TB OF TB_CPU IS\r\n    COMPONENT CPU_IF\r\n        PORT \r\n    END COMPONENT;\r\n    SIGNAL CPU_DATA_VALID : std_ulogic;\r\n    SIGNAL CLK, RESET : std_ulogic := '0';\r\n    CONSTANT PERIOD : TIME := 10 ns;\r\n    CONSTANT MAX_SIM : TIME := 50 * PERIOD;\r\nBEGIN\r\nEND TB;";
    actual = beautify(input, no_format, true, remove_report, check_alias, sign_align, sign_align_all, new_line, keywordcase, indentation, new_line_after_port);
    console.log("Remove comments", actual == expected);

    input = "entity TB_DISPLAY is\r\n-- port declarations\r\nend TB_DISPLAY;\r\n\r\narchitecture TEST of TB_DISPLAY is\r\n-- signal declarations\r\nbegin\r\n-- component instance(s)\r\nend TEST;";
    expected = "ENTITY TB_DISPLAY IS\r\n    -- port declarations\r\nEND TB_DISPLAY;\r\n\r\nARCHITECTURE TEST OF TB_DISPLAY IS\r\n    -- signal declarations\r\nBEGIN\r\n    -- component instance(s)\r\nEND TEST;";
    actual = beautify(input, no_format, remove_comments, remove_report, check_alias, sign_align, sign_align_all, new_line, keywordcase, indentation, new_line_after_port);
    console.log("ENTITY ARCHITECTURE", CompareString(actual, expected));

    input = "port map(\r\ninput_1 => input_1_sig,\r\ninput_2 => input_2_sig,\r\noutput => output_sig\r\n);";
    expected = "PORT MAP(\r\n    input_1  => input_1_sig, \r\n    input_2  => input_2_sig, \r\n    output   => output_sig\r\n);";
    actual = beautify(input, no_format, remove_comments, remove_report, check_alias, true, sign_align_all, new_line, keywordcase, indentation, new_line_after_port);
    console.log("Sign align in PORT", actual == expected);

    input = 'if a(3 downto 0) > "0100" then\r\na(3 downto 0) := a(3 downto 0) + "0011" ;\r\nend if ;';
    expected = 'IF a(3 DOWNTO 0) > "0100" THEN\r\n    a(3 DOWNTO 0) := a(3 DOWNTO 0) + "0011";\r\nEND IF;';
    actual = beautify(input, no_format, remove_comments, remove_report, check_alias, sign_align, sign_align_all, new_line, keywordcase, indentation, new_line_after_port);
    console.log("IF END IF case 1", CompareString(actual, expected));
    
    input = "if s = '1' then\r\no <= \"010\";\r\nelse\r\no <= \"101\";\r\nend if;";
    expected = "IF s = '1' THEN\r\n    o <= \"010\";\r\nELSE\r\n    o <= \"101\";\r\nEND IF;";
    actual = beautify(input, no_format, remove_comments, remove_report, check_alias, sign_align, sign_align_all, new_line, keywordcase, indentation, new_line_after_port);
    console.log("IF ELSE END IF case 1", actual == expected);

    input = "IF (s = r) THEN rr := '0'; ELSE rr := '1'; END IF;";
    expected = "IF (s = r) THEN\r\n    rr := '0';\r\nELSE\r\n    rr := '1';\r\nEND IF;";
    actual = beautify(input, no_format, remove_comments, remove_report, check_alias, sign_align, sign_align_all, new_line, keywordcase, indentation, new_line_after_port);
    console.log("IF ELSE END IF case 2", actual == expected);

    input = 'P1:process\r\nvariable x: Integer range 1 to 3;\r\nvariable y: BIT_VECTOR (0 to 1);\r\nbegin\r\n  C1: case x is\r\n      when 1 => Out_1 <= 0;\r\n      when 2 => Out_1 <= 1;\r\n  end case C1;\r\n  C2: case y is\r\n      when "00" => Out_2 <= 0;\r\n      when "01" => Out_2 <= 1;\r\n  end case C2;\r\nend process;';
    expected = 'P1 : PROCESS\r\n    VARIABLE x : INTEGER RANGE 1 TO 3;\r\n    VARIABLE y : BIT_VECTOR (0 TO 1);\r\nBEGIN\r\n    C1 : CASE x IS\r\n        WHEN 1 => Out_1 <= 0;\r\n        WHEN 2 => Out_1 <= 1;\r\n    END CASE C1;\r\n    C2 : CASE y IS\r\n        WHEN "00" => Out_2 <= 0;\r\n        WHEN "01" => Out_2 <= 1;\r\n    END CASE C2;\r\nEND PROCESS;';
    actual = beautify(input, no_format, remove_comments, remove_report, check_alias, sign_align, sign_align_all, new_line, keywordcase, indentation, new_line_after_port);
    console.log("WHEN CASE", CompareString(actual, expected));

    input = "case READ_CPU_STATE is\r\n  when WAITING =>\r\n    if CPU_DATA_VALID = '1' then\r\n      CPU_DATA_READ  <= '1';\r\n      READ_CPU_STATE <= DATA1;\r\n    end if;\r\n  when DATA1 =>\r\n    -- etc.\r\nend case;";
    expected = "CASE READ_CPU_STATE IS\r\n    WHEN WAITING => \r\n        IF CPU_DATA_VALID = '1' THEN\r\n            CPU_DATA_READ <= '1';\r\n            READ_CPU_STATE <= DATA1;\r\n        END IF;\r\n    WHEN DATA1 => \r\n        -- etc.\r\nEND CASE;";
    actual = beautify(input, no_format, remove_comments, remove_report, check_alias, sign_align, sign_align_all, new_line, keywordcase, indentation, new_line_after_port);
    console.log("WHEN CASE & IF", CompareString(actual, expected));

    input = "entity aa is\r\n    port (a : in std_logic;\r\n          b : in std_logic;\r\n         );\r\nend aa;\r\narchitecture bb of aa is\r\n   component cc\r\n    port(\r\n         a : in std_logic;\r\n         b : in std_logic;\r\n        );\r\n    end cc;\r\n\r\nbegin\r\n  C : cc port map (\r\n          long => a,\r\n          b => b\r\n        );\r\nend;";
    expected = "ENTITY aa IS\r\n    PORT (\r\n        a : IN std_logic;\r\n        b : IN std_logic;\r\n    );\r\nEND aa;\r\nARCHITECTURE bb OF aa IS\r\n    COMPONENT cc\r\n        PORT (\r\n            a : IN std_logic;\r\n            b : IN std_logic;\r\n        );\r\n    END cc;\r\n\r\nBEGIN\r\n    C : cc\r\n    PORT MAP(\r\n        long => a, \r\n        b => b\r\n    );\r\nEND;";
    actual = beautify(input, no_format, remove_comments, remove_report, check_alias, sign_align, sign_align_all, new_line, keywordcase, indentation, new_line_after_port);
    console.log("PORT MAP", CompareString(actual, expected));

    input = "entity aa is\r\n    port (a : in std_logic;\r\n          b : in std_logic;\r\n         );\r\n    port (a : in std_logic;\r\n          b : in std_logic;\r\n         );\r\nend aa;\r\narchitecture bb of aa is\r\n   component cc\r\n    port(\r\n         a : in std_logic;\r\n         b : in std_logic;\r\n        );\r\n    port(\r\n         a : in std_logic;\r\n         b : in std_logic;\r\n        );\r\n    end cc;\r\n\r\nbegin\r\n  C : cc port map (\r\n          long => a,\r\n          b => b\r\n        );\r\n  D : cc port map (\r\n          long => a,\r\n          b => b\r\n        );\r\nend;";
    expected = "ENTITY aa IS\r\n    PORT (\r\n        a : IN std_logic;\r\n        b : IN std_logic;\r\n    );\r\n    PORT (\r\n        a : IN std_logic;\r\n        b : IN std_logic;\r\n    );\r\nEND aa;\r\nARCHITECTURE bb OF aa IS\r\n    COMPONENT cc\r\n        PORT (\r\n            a : IN std_logic;\r\n            b : IN std_logic;\r\n        );\r\n        PORT (\r\n            a : IN std_logic;\r\n            b : IN std_logic;\r\n        );\r\n    END cc;\r\n\r\nBEGIN\r\n    C : cc\r\n    PORT MAP(\r\n        long => a, \r\n        b => b\r\n    );\r\n    D : cc\r\n    PORT MAP(\r\n        long => a, \r\n        b => b\r\n    );\r\nEND;";
    actual = beautify(input, no_format, remove_comments, remove_report, check_alias, sign_align, sign_align_all, new_line, keywordcase, indentation, new_line_after_port);
    console.log("Multiple PORT MAPs", CompareString(actual, expected));
	
    input = "port (a : in std_logic;\r\n b : in std_logic;\r\n);";
    expected = "PORT \r\n(\r\n    a : IN std_logic;\r\n    b : IN std_logic;\r\n);";
    actual = beautify(input, no_format, remove_comments, remove_report, check_alias, sign_align, sign_align_all, new_line, keywordcase, indentation, true);
    console.log("New line aster PORT", CompareString(actual, expected));
    
    input = "component a is\r\nport( Data : inout Std_Logic_Vector(7 downto 0););\r\nend component a;";
    expected = "COMPONENT a IS\r\n    PORT (Data : INOUT Std_Logic_Vector(7 DOWNTO 0););\r\nEND COMPONENT a;";
    actual = beautify(input, no_format, remove_comments, remove_report, check_alias, sign_align, sign_align_all, new_line, keywordcase, indentation, true);
    console.log("New line aster PORT (single line)", CompareString(actual, expected));
    
    input = "process xyx (vf,fr,\r\nde -- comment\r\n)";
    expected = "PROCESS xyx (vf, fr, \r\n             de -- comment\r\n             )";
    actual = beautify(input, no_format, remove_comments, remove_report, check_alias, sign_align, sign_align_all, new_line, keywordcase, indentation, true);
    console.log("Align parameters in PROCESS", CompareString(actual, expected));
	
	input = "architecture a of b is\r\nbegin\r\n    process (w)\r\n    variable t : std_logic_vector (4 downto 0) ;\r\nbegin\r\n    a := (others => '0') ;\r\nend process ;\r\nend a;";
    expected = "ARCHITECTURE a OF b IS\r\nBEGIN\r\n    PROCESS (w)\r\n    VARIABLE t : std_logic_vector (4 DOWNTO 0);\r\n    BEGIN\r\n        a := (OTHERS => '0');\r\n    END PROCESS;\r\nEND a;";
    actual = beautify(input, no_format, remove_comments, remove_report, check_alias, sign_align, sign_align_all, new_line, keywordcase, indentation, true);
    console.log("Double BEGIN", CompareString(actual, expected));
    
	input = "entity a is\r\n    port ( w  : in  std_logic_vector (7 downto 0) ;\r\n           w_s : out std_logic_vector (3 downto 0) ; ) ;\r\nend a ;\r\narchitecture b of a is\r\nbegin\r\n    process ( w )\r\n    variable t : std_logic_vector (4 downto 0) ;\r\n    variable bcd     : std_logic_vector (11 downto 0) ;\r\nbegin\r\n    b(2 downto 0) := w(7 downto 5) ;\r\n    t         := w(4 downto 0) ;\r\n    w_s <= b(11 downto 8) ;\r\n    w <= b(3  downto 0) ;\r\nend process ;\r\nend b ;";
    expected = "ENTITY a IS\r\n    PORT \r\n    (\r\n        w   : IN std_logic_vector (7 DOWNTO 0);\r\n        w_s : OUT std_logic_vector (3 DOWNTO 0); \r\n    );\r\nEND a;\r\nARCHITECTURE b OF a IS\r\nBEGIN\r\n    PROCESS (w)\r\n    VARIABLE t   : std_logic_vector (4 DOWNTO 0);\r\n    VARIABLE bcd : std_logic_vector (11 DOWNTO 0);\r\n    BEGIN\r\n        b(2 DOWNTO 0) := w(7 DOWNTO 5);\r\n        t             := w(4 DOWNTO 0);\r\n        w_s <= b(11 DOWNTO 8);\r\n        w   <= b(3 DOWNTO 0);\r\n    END PROCESS;\r\nEND b;";
    actual = beautify(input, no_format, remove_comments, remove_report, check_alias, sign_align, true, new_line, keywordcase, indentation, true);
    console.log("Align signs in all places", CompareString(actual, expected));

    input = "begin\r\n  P0 : process(input)\r\n  variable value: Integer;\r\n  begin\r\n    result(i) := '0';\r\n  end process P0;\r\nend behavior;";
    expected = "BEGIN\r\n    P0 : PROCESS (input)\r\n        VARIABLE value : INTEGER;\r\n    BEGIN\r\n        result(i) := '0';\r\n    END PROCESS P0;\r\nEND behavior;";
    actual = beautify(input, no_format, remove_comments, remove_report, check_alias, sign_align, false, new_line, keywordcase, indentation, true);
    console.log("Indent after Begin", CompareString(actual, expected));
}

function CompareString(s1, s2) {
    var l = Math.min(s1.length, s2.length);
    for (var i = 0; i < l; i++) {
        if (s1[i] != s2[i]) {
            var toEnd = Math.min(i + 50, l);
            return '\ndifferent at ' + i.toString() + '\nactual: "\n' + s1.substring(i, toEnd) + '\nexpected: "\n' + s2.substring(i, toEnd) + '"' + "\nactual: \n" + s1;
        }
    }
    return true;
}
UnitTest();
</script>
</body>
</html>
